package v4;

import org.apache.kafka.clients.consumer.KafkaConsumer;
import redis.clients.jedis.Jedis;
import v4.domain.*;
import v4.kafka.KafkaEventConsumerFactory;
import v4.read.InMemoryReadModel;
import v4.read.VehicleProjection;
import v4.read.VehicleProjectionRedis;
import v4.write.*;

// Demo class to demonstrate the usage of the command handler for executing commands related to vehicle creation,
// movement, and removal, and to show the resulting events produced by these commands being sent to
// Kafka, and consumed by two different projections: one that updates an in-memory read model, and another that updates a Redis store.
public class KafkaDemo {

    public static void main(String[] args) throws Exception {
        String bootstrap = "localhost:9092";
        String topic = "vehicle-events";

        // In-memory event producer to capture the events generated by the command handler for demonstration purposes.
        InMemoryEventProducer inMemoryProducer = new InMemoryEventProducer();
        EventStoreRepository repo = new EventStoreRepository(inMemoryProducer);
        VehicleAggregateLoader loader = new VehicleAggregateLoader(repo);

        // In-memory read model to be used by the command handler for checking the current state of vehicles when executing commands.
        InMemoryReadModel readModel = new InMemoryReadModel();

        // Command handler that uses the in-memory event producer to send commands and the aggregate loader to load the current state of the vehicle aggregates.
        IVehicleCommands commands = new VehicleCommandHandler(inMemoryProducer, loader, readModel);

        // Kafka event producer to send the events generated by the in-memory producer to a Kafka topic.
        EventProducer kafkaProducer = new EventProducer(bootstrap, topic);

        // Runnable to forward all events from the in-memory producer to Kafka, which can be called after executing the commands to ensure that all generated events are sent to Kafka for the projections to consume.
        Runnable forwardAllEventsToKafka = () -> {
            inMemoryProducer.getEvents().forEach(kafkaProducer::send);
        };

        // Kafka consumer for the in-memory projection, which will consume events from the Kafka topic and update the in-memory read model accordingly.
        KafkaConsumer<String, IVehicleEvent> projectionConsumer =
                KafkaEventConsumerFactory.createConsumer(
                        bootstrap,
                        "vehicle-projection-inmemory-v4-" + System.currentTimeMillis()
                );
        VehicleProjection projection = new VehicleProjection(projectionConsumer, readModel);
        Thread projectionThread = new Thread(projection, "projection-inmemory");
        projectionThread.setDaemon(true);
        projectionThread.start();

        // Kafka consumer for the Redis projection, which will consume events from the Kafka topic and update the Redis store accordingly.
        KafkaConsumer<String, IVehicleEvent> redisProjectionConsumer =
                KafkaEventConsumerFactory.createConsumer(
                        bootstrap,
                        "vehicle-projection-redis-v4-" + System.currentTimeMillis()
                );

        // Jedis client to connect to the Redis server, which will be used by the Redis projection to update the vehicle data in Redis based on the consumed events.
        Jedis jedis = new Jedis("localhost", 6379);
        VehicleProjectionRedis redisProjection =
                new VehicleProjectionRedis(redisProjectionConsumer, jedis);
        Thread redisThread = new Thread(redisProjection, "projection-redis");
        redisThread.setDaemon(true);
        redisThread.start();

        // Execute a series of commands to create a vehicle, move it, and then remove it, which will generate events
        // that are captured by the in-memory producer and then forwarded to Kafka for the projections to consume and update their respective read models.
        commands.createVehicle("car1", new Position(0, 0));
        commands.moveVehicle("car1", new Position(1, 0));
        commands.moveVehicle("car1", new Position(0, 2));

        commands.createVehicle("car2", new Position(10, 10));

        // Apply the generated events to the in-memory read model to update its state before forwarding the events to Kafka,
        // ensuring that the in-memory projection has the updated state when it consumes the events from Kafka.
        inMemoryProducer.getEvents().forEach(event -> {
            if (event instanceof VehicleCreatedEvent e) {
                readModel.apply(e);
            } else if (event instanceof VehicleMovedEvent e) {
                readModel.apply(e);
            } else if (event instanceof VehicleRemovedEvent e) {
                readModel.apply(e);
            }
        });

        // Forward all generated events from the in-memory producer to Kafka, allowing the projections to
        // consume these events and update their respective read models (in-memory and Redis) accordingly.
        forwardAllEventsToKafka.run();

        Thread.sleep(3000);

        String[] knownVehicles = {"vehicle:car1", "vehicle:car2"};
        for (String key : knownVehicles) {
            String value = jedis.get(key);
            if (value != null) {
                System.out.println("Redis: " + value);
            }
        }

        // kafkaProducer.close();
        // projectionConsumer.close();
        //redisProjectionConsumer.close();
        jedis.close();
    }
}
